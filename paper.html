<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta http-equiv="Content-Style-Type" content="text/css">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="generator" content="pandoc">
        <title>Massage Tree - self-adjusting, self-balancing binary trees</title>
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
        <style type="text/css">code { white-space: pre; }
body, html {
  background: white;
}
/* p, h1, h2, h3, h5 { font-family: Times, times, serif; } */
h1, h2, h3, h4, h5, a { color: black; text-decoration: none; }
h1, h2, h3, h4, h5, p, .proofpart { padding: 0.5em; margin: 0.5em; }
table.pure-table { padding: 2.0em; margin: 2.0em; }
ul { padding-top: 0; padding-bottom:0; margin-top: 0; margin-bottom: 0; }
.leCode .math {
  /* background: #ffc; */
  border: 1px dashed grey;
  padding: 0.5em;
  margin: 0.2em;
}
.le-code-cont > .caption {
  text-align:center;
  width:100%;
  font-size:75%;
}
.le-code-cont {
  /* margin: 0.8em 0; */
  margin: 0;
}
.le-code-cont .MathJax_Display {
  margin: 0.2em 0;
}
.proofpart {
  font-variant: small-caps;
  padding-left: 1em;
}
.proofend {
  font-size: 110%;
  font-weight: bold;
  padding-bottom: 2em;
}</style>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    </head>
    <body>
        <div class="pure-g">
            <div class="pure-u-1">
                <p>
                    <em>Michele Bini <michele.bini@gmail.com>, 2014-02-22; last draft: 2015-01-14</em>
                </p>
                <p>The self-adjusting property of splay trees is combined with a self-balancing property, thereby improving the worst-case complexity of basic operations from linear to logarithmic to the size of the tree. The resulting persistent data structures can be used to efficiently and adaptively simulate other specialized data structures.</p>
                <p>Keywords: self-balancing trees, self-adjusting</p>
                <div id="TOC">
                    <ul>
                        <li>
                            <a href="#introduction">Introduction</a>
                        </li>
                        <li>
                            <a href="#basic-theories-and-techniques">Basic theories and techniques</a>
                            <ul>
                                <li>
                                    <a href="#functional-set-operations">Functional set operations</a>
                                </li>
                                <li>
                                    <a href="#binary-search-trees">Binary search trees</a>
                                </li>
                                <li>
                                    <a href="#evaluating-tree-balance">Evaluating tree balance</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#functional-splay-trees">Functional splay trees</a>
                            <ul>
                                <li>
                                    <a href="#integrated-splay-tree-operations">Integrated splay tree operations</a>
                                </li>
                                <li>
                                    <a href="#analysis-of-the-splay-operation">Analysis of the splay operation</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#massage-operation">Incrementally rebalancing a splay tree: the massage operation</a>
                            <ul>
                                <li>
                                    <a href="#operations-on-massage-trees">Operations on massage trees</a>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <a href="#experimental-results">Experimental results</a>
                        </li>
                        <li>
                            <a href="#applications">Applications</a>
                            <ul>
                                <li><a href="#queues">Queues</a></li>
                                <li><a href="#deques">Deques</a></li>
                                <li><a href="#dynamic-arrays">Dynamic arrays</a></li>
                                <li><a href="#linked-lists">Linked-lists</a></li>
                                <li><a href="#ropes">Ropes</a></li>
                            </ul>
                        </li>
                        <li><a href="#conclusions">Conclusions</a></li>
                        <li><a href="#literature-cited">Literature Cited</a>
                        </li>
                    </ul>
                </div>
                <h2 id="introduction"><a href="#introduction">Introduction</a></h2>
                <p>Among the data structures available to programmers, some of them, like lists, stacks or queues are specialized for sequential, or local-access operations. Others, like balanced trees, are specialized for random-access operations.</p>
                <p>
The goal of this paper is addressing the duality between these data-structures, by providing algorithms for a generic tree structure reconciling constant time bounds for sequential and local operations, with logarithmic time bounds for random-access operations. For brevity in this paper ``focal'' will be used to indicate either sequential or local type of accesses and combinations of them.
</p>
                <table class="pure-table">
                    <tr>
                        <td>
                        </td>
                        <th colspan="2"> 
random<br/>insert/replace/delete
</th>
                        <th> 
focal<br/>insert/replace/delete
</th>
                    </tr>
                    <tr>
                        <td>
                        </td>
                        <th>
amortized
</th>
                        <th>
worst-case
</th>
                        <th>
amortized
</th>
                    </tr>
                    <tr>
                        <td>
Red-black tree
</td>
                        <td>
O(log(n))
</td>
                        <td>
O(log(n))
</td>
                        <td>
O(log(n))
</td>
                    </tr>
                    <tr>
                        <td>
Splay tree
</td>
                        <td>
O(log(n))
</td>
                        <td>
O(n)
</td>
                        <td>
                            <strong>O(1)</strong>
                        </td>
                    </tr>
                    <tr>
                        <td>
Massage tree
</td>
                        <td>
O(log(n))
</td>
                        <td>
                            <strong>O(log(n))</strong>
                        </td>
                        <td>
O(1)
</td>
                    </tr>
                </table>
                <p>This paper will first cover basic techniques and theories for splay trees, then describe a rebalancing operation with amortized constant time complexity that can be employed to lower the worst-case time bounds of all basic operations.</p>
                <p>Finally, a fully constant-time rebalancing operation is embedded into the splay operation.</p>
                <p>Each step will supported by theoretically and/or experimentally.</p>
                <p>For ease of analisys of the time bounds, an eager order of execution will be assumed.  The pseudocode in this paper is in a fictional, indentation-sensitive language inspired by Mythyrl.</p>
                <p>The code (pseudocode) in this paper, delimited by dashed borders, is licensed under GPLv3+.</p>
                <h1 id="basic-theories-and-techniques">
                    <a href="#basic-theories-and-techniques">Basic theories and techniques</a>
                </h1>
                <h2 id="functional-set-operations">
                    <a href="#functional-set-operations">Functional set operations</a>
                </h2>
                <div style="height:0;max-height:0;padding:0;margin:0;border:0;overflow:hidden">
                    <p>
                        <div class="le-code-cont">
                            <div class="leCode math">\[
\newcommand{\lincell}{\cellcolor{gray2}\text{linear}}
\newcommand{\logcell}{\cellcolor{gray1}\text{logarithmic}}
\newcommand{\concell}{\text{constant}}
\newcommand{\insert}{\mathit{\textbf{insert}}}
\newcommand{\member}{\textbf{member}}
\newcommand{\concat}{\textbf{concat}}
\newcommand{\delete}{\textbf{delete}}
\newcommand{\queuepush}{\mathit{\textbf{push}}}
\newcommand{\queuepop}{\textbf{pop}}
\newcommand{\seqfirst}{\textbf{first}}
\newcommand{\seqlast}{\textbf{last}}
\newcommand{\seqjoin}{\textbf{join}}
\newcommand{\seqsplit}{\textbf{split}}
\newcommand{\height}{\textbf{h}}
\newcommand{\size}{\textbf{s}}
\newcommand{\Tree}{\mathsf{Tree}}
\newcommand{\Measures}{\mathsf{Measures}}
\newcommand{\Height}{\mathsf{Height}}
\newcommand{\node}{\textbf{node}}
\newcommand{\splay}{\textbf{splay}}
\newcommand{\massage}{\textbf{massage}}
\newcommand{\descend}{\textbf{descend}}
\newcommand{\compress}{\textbf{pack}}
\newcommand{\add}{\textbf{add}}
\newcommand{\build}{\textbf{build}}
\newcommand{\ascend}{\textbf{ascend}}
\newcommand{\loopy}{\textbf{loop}}
\newcommand{\true}{\boldsymbol{\top}}
\newcommand{\false}{\boldsymbol{\bot}}
\newcommand{\indent}{\;\;\;\;}
\newcommand{\gentree}{\textbf{G}}
\newcommand{\baltree}{\textbf{B}}
\newcommand{\splayop}{\textbf{Spl}}
\newcommand{\genop}{\textbf{Gen}}
\newcommand{\massageop}{\textbf{Mas}}
\newcommand{\OrderedSet}{\textbf{X}}
\newcommand{\emptytup}{\varnothing}
\newcommand{\balancedness}{\textbf{b}}
\newcommand{\codedescription}[1]{\mathit{#1}}
\]</div>
                        </div>
                    </p>
                </div>
                <p>In the context of this paper, <span class="math">\(\OrderedSet\)</span> is a totally ordered set, while <span class="math">\(\member,\insert,\delete\)</span> are functions whose type can be described by the set <span class="math">\(\left\{ (t_{1},x)\to t_{2}|x\in\OrderedSet\land t_{x}\in\mathbf{T}\right\} \)</span>, where <span class="math">\(\mathbf{T}\)</span> is the data type of a tree set implementation.</p>
                <h2 id="binary-search-trees"><a href="#binary-search-trees">Binary search trees</a></h2>
                <p>It is straightforward to define simple <span class="math">\(\member\)</span> and <span class="math">\(\insert\)</span> operations on a generic binary search tree:</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \gentree=\left\{ \emptytup_{\gentree},\left\langle l,x,r\right\rangle _{\gentree}\mid l,r\in\gentree\land x\in\OrderedSet\right\} \end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \member(\emptytup_{\gentree},x) &amp;  &amp; \to\false\\
 &amp; \member(\left\langle l,m,r\right\rangle _{\gentree},x) &amp;  &amp; \to
\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent x&lt;m &amp;  &amp; \Rightarrow\member(l,x)\\
 &amp; \indent x&gt;m &amp;  &amp; \Rightarrow\member(r,x)\\
 &amp; \indent x=m &amp;  &amp; \Rightarrow\true
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \insert(\emptytup_{\gentree},x) &amp;  &amp; \to\left\langle \emptytup_{\gentree},x,\emptytup_{\gentree}\right\rangle _{\gentree}\\
 &amp; \insert(\left\langle l,m,r\right\rangle _{\gentree},x) &amp;  &amp; \to
\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent x&lt;m &amp;  &amp; \Rightarrow\left\langle \insert(l,x),m,r\right\rangle _{\gentree}\\
 &amp; \indent x&gt;m &amp;  &amp; \Rightarrow\left\langle l,m,\insert(r,x)\right\rangle _{\gentree}\\
 &amp; \indent x=m &amp;  &amp; \Rightarrow\left\langle l,x,r\right\rangle _{\gentree}
\end{aligned}
\end{align}
\]</div>
                        <div class="caption">Implementation of basic set operations on a binary search tree</div>
                    </div>
                </p>
                <p>A delete operation is necessarily more complex than insert on binary search trees, since deletions can also occur in a node with branches. Implementations of this operation for generic binary search trees are omitted for brevity and not used by other code of this paper.</p>
                <h2 id="evaluating-tree-balance"><a href="#evaluating-tree-balance">Evaluating tree balance</a></h2>
                <p>Basic operations on binary trees have worst-case time bounds proportional to the height of the tree, defined as the distance between the root node and the deepest node of the tree.</p>
                <section>
                    <em class="proofpart">Lemma:</em>
                    <span>A perfectly balanced binary tree of height </span>
                    <span class="math">\(h\)</span> has size <span class="math">\(2^{h}-1\)</span>.</section>
                <section>
                    <em class="proofpart">Proof:</em>
                    <p>Let <span class="math">\(\size_{\text{t}}(h)\)</span> be the size of a perfect binary tree of height <span class="math">\(h\)</span>.</p>
                    <p><span class="math">\[
\begin{eqnarray}
\size_{\text{t}}(1) &amp; = &amp; 1\\
\size_{\text{t}}(n) &amp; = &amp; \size_{\text{t}}(n-1)+2^{n-1}\\
\size_{\text{t}}(n) &amp; = &amp; \sum_{x=1}^{n}2^{n-1}=1\frac{1-2^{n}}{1-2}=2^{n}-1
\end{eqnarray}
\]</span></p>
                    <p> The height of a perfectly balanced binary tree of size s is <span class="math">\(\height_{\text{t}}(s)=\log_{2}(s+1)\)</span> for <span class="math">\((s+1)\in\left\{ x^{2}\mid x\in\mathbb{N}\right\} \)</span>. For arbitrary sizes, rounding up the result is necessary:</p>
                    <p class="proofpart proofend">∎</p>
                </section>
                <p><span class="math">\[
\begin{equation}
\height_{\text{t}}(s)=\left\lceil \log_{2}(s+1)\right\rceil \in\mathbb{N}
\end{equation}
\]</span></p>
                <p>The balancedness <span class="math">\(\balancedness(t)\)</span> of a non-empty tree <span class="math">\(t\)</span> can be defined as the ratio between the height for a balanced binary tree of the same size and the measured height of the tree. <span class="math">\[
\begin{align}
\balancedness(t) &amp; =\frac{\height_{\text{t}}(\size(t))}{\height(t)}\in\{x\mid x\in\mathbb{R}\land0&lt;x\le1\}
\end{align}
\]</span></p>
                <p>By annotating each node with the size and height of the corresponding subtree, it is possible to calculate the balancedness of trees in constant time. A smart constructor (2.18) can be defined to maintain the size and height annotations of the nodes.</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \mathbf{\baltree}=\left\{ \emptytup_{\baltree},\left\langle \left\langle h,s\right\rangle ,l,x,r\right\rangle _{\baltree}\mid h,s\in\mathbb{N}\land l,r\in\mathbf{\baltree}\land x\in\OrderedSet\right\} \end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \size(\emptytup_{\baltree}) &amp;  &amp; \to0\\
 &amp; \size\left\langle \left\langle \_,s\right\rangle ,\_,\_,\_\right\rangle _{\baltree} &amp;  &amp; \to s
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \height(\emptytup_{\baltree}) &amp;  &amp; \to0\\
 &amp; \height\left\langle \left\langle h,\_\right\rangle ,\_,\_,\_\right\rangle _{\baltree} &amp;  &amp; \to h
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \left\langle l,m,r\right\rangle _{\baltree}\to\left\langle \left\langle \height(l)\oplus\height(r)+1,\size(l)+\size(r)+1\right\rangle ,l,m,r\right\rangle _{\baltree}\end{aligned}
\end{align}
\]</div>
                        <div class="caption">Implementation of height and size annotations for binary trees, with smart constructor</div>
                    </div>
                </p>
                <p>In this definition, the operator <span class="math">\(\oplus\)</span> returns the maximum of the two operands.</p>
                <h1 id="functional-splay-trees"><a href="#functional-splay-trees">Functional splay trees</a></h1>
                <p>Splay trees do not require any node annotation, thus they can use the same data structure primitives as other binary search trees. The characterizing operation on splay trees is the splay operation, having two crucial properties (Sleator and Tarjan, 1985)</p>
                <ul>
                    <li>bringing to the top the target node</li>
                    <li>reduce the height of the tree along the path to the target node</li>
                </ul>
                <p>The novel algorithm presented here subdivides the splay operation into a descending (2.16) phase, which accumulates lists of trees on either side of the path to the target node, and an ascending (2.18) phase, during which the lists of trees are assembled into a pair of trees of reduced height and placed as subtreres on either side of the target node.</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \splay(\emptytup_{\gentree},x) &amp;  &amp; \to\emptytup_{\gentree}\\
 &amp; \splay(t,x) &amp;  &amp; \to\descend(x,t,\left\langle \left[\right],\left[\right]\right\rangle )
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend(x,t\equiv\left\langle l,m,r\right\rangle _{\gentree},f)\to\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent x&lt;m\Rightarrow\descend^{\prime}(x,l,\add_{r}(m,r,f),t,f)\\
 &amp; \indent x&gt;m\Rightarrow\descend^{\prime}(x,r,\add_{l}(m,l,f),t,f)\\
 &amp; \indent x=m\Rightarrow\ascend(m,l,r,f)
\end{aligned}
\nonumber \\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend^{\prime}(\_,\emptytup_{\gentree},\_,\left\langle l,m,r\right\rangle _{\gentree},f) &amp;  &amp; \to\ascend(m,l,r,f)\\
 &amp; \descend^{\prime}(x,t,f,\_,\_) &amp;  &amp; \to\descend(x,t,f)
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \ascend(m,l,r,\left\langle l_{f,},r_{f}\right\rangle )\to\\
 &amp; \indent\left\langle \build(\node_{l},l,l_{f}),m,\build(\node_{r},r,r_{f})\right\rangle _{\gentree}
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \add_{r}(m,r,\left\langle f_{l},f_{r}\right\rangle )\to\left\langle f_{l},\left[\left\langle m,r\right\rangle ,f_{r}\dots\right]\right\rangle \\
 &amp; \add_{l}(m,l,\left\langle f_{l},f_{r}\right\rangle )\to\left\langle \left[\left\langle m,l\right\rangle ,f_{l}\dots\right],f_{r}\right\rangle 
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \node_{r}(l,m,r)\to\left\langle l,m,r\right\rangle _{\gentree}\\
 &amp; \node_{l}(r,m,l)\to\left\langle l,m,r\right\rangle _{\gentree}
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \build(n,t,\left[\left\langle v_{a},t_{a}\right\rangle ,\left\langle v_{b},t_{b}\right\rangle ,f\dots\right])\to\build(n,n(t,v_{a},n(t_{a},v_{b},t_{b}),f))\\
 &amp; \build(n,t,\left[\left\langle v_{a},t_{a}\right\rangle \right])\to n(t,v_{a},t_{a})\\
 &amp; \build(n,t,\left[\right])\to t
\end{aligned}
\end{align}
\]</div>
                        <div class="caption">implementation of a functional splay operation</div>
                    </div>
                </p>
                <p>This splay variant has been shown experimentally to be more performant than a top-down functional splaying algorithm, and has the additional advantages of a concise implementation and simpler analysis.</p>
                <p>The splay operation is typically performed before other basic operations to bring the target node to the top, and to optimize subsequent operations in the same locality of reference:</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \member_{\splayop}(t,x)\to(\splay(t,x),\member_{\genop}(\splay(t,x),x))\\
 &amp; \indent t\leftarrowtail\splay(t,x)\\
 &amp; \indent\left\langle t,\member_{\genop}(t,x)\right\rangle \\
\\
 &amp; \insert_{\splayop}(t,x)\to\insert_{\genop}(\splay(t,x),x)\\
 &amp; \delete_{\splayop}(t,x)\to\delete_{\genop}(\splay(t,x),x)
\end{aligned}
\end{align}
\]</div>
                    </div>
                </p>
                <p>It is equivalently possible to perform the splay operation  the corresponding function for generic binary search tree: <span class="math">\[
\begin{equation}
\begin{cases}
 &amp; f_{1}(t,x)=\splay(f_{\genop}(t,x),x)\\
 &amp; f_{2}(t,x)=f_{\genop}(\splay(t,x),x)
\end{cases}
\end{equation}
\]</span></p>
                <h2 id="integrated-splay-tree-operations"><a href="#integrated-splay-tree-operations">Integrated splay tree operations</a></h2>
                <p>For optimal performance of implementations of splay trees, it is adviced to embed the splay operation into the basic binary search tree operation.</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \member_{\splayop}(\emptytup_{\gentree},x) &amp;  &amp; \to\left\langle \emptytup_{\gentree},\false\right\rangle \\
 &amp; \member_{\splayop}(t,x) &amp;  &amp; \to\descend(x,t,\left\langle \left[\right],\left[\right]\right\rangle )
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend(x,t\equiv\left\langle l,m,r\right\rangle _{\gentree},f)\to\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent x&lt;m\Rightarrow\descend^{\prime}(x,l,\add_{r}(m,r,f),t,f)\\
 &amp; \indent x&gt;m\Rightarrow\descend^{\prime}(x,r,\add_{l}(m,l,f),t,f)\\
 &amp; \indent x=m\Rightarrow\ascend(\true,m,l,r,f)
\end{aligned}
\nonumber \\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend^{\prime}(\_,\emptytup_{\gentree},\_,\left\langle l,m,r\right\rangle _{\gentree},f) &amp;  &amp; \to\ascend(\false,m,l,r,f)\\
 &amp; \descend^{\prime}(x,t,f,\_,\_) &amp;  &amp; \to\descend(x,t,f)
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \ascend(v,x,l,r,\left\langle l_{f,},r_{f}\right\rangle )\to\\
 &amp; \indent\left\langle \left\langle \build(\node_{l},l,l_{f}),x,\build(\node_{r},r,r_{f})\right\rangle _{\gentree},v\right\rangle 
\end{aligned}
\end{align}
\]</div>
                        <div class="caption">Implementation of a member+splay operation</div>
                    </div>
                </p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \insert_{\splayop}(\emptytup_{\gentree},x) &amp;  &amp; \to\left\langle \emptytup_{\gentree},x,\emptytup_{\gentree}\right\rangle _{\gentree}\\
 &amp; \insert_{\splayop}(t,x) &amp;  &amp; \to\descend(x,t,\left\langle \left[\right],\left[\right]\right\rangle )
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend(x,t\equiv\left\langle l,m,r\right\rangle _{\gentree},f)\to\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent x&lt;m\Rightarrow\descend^{\prime}(x,l,\add_{r}(m,r,f))\\
 &amp; \indent x&gt;m\Rightarrow\descend^{\prime}(x,r,\add_{l}(m,l,f))\\
 &amp; \indent x=m\Rightarrow\ascend(x,l,r,f)
\end{aligned}
\nonumber \\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend^{\prime}(x,\emptytup_{\gentree},f) &amp;  &amp; \to\ascend(x,\emptytup_{\gentree},\emptytup_{\gentree},f)\\
 &amp; \descend^{\prime}(x,t,f) &amp;  &amp; \to\descend(x,t,f)
\end{aligned}
\end{align}
\]</div>
                        <div class="caption">Implementation of an insert+splay operation</div>
                    </div>
                </p>
                <p>In the original paper for splay trees (Sleator and Tarjan, 1985:662), basic set operations are constructed by first embedding the splay operation into each access/join/split operation, then defining insert and delete in terms of split and join. While conceptually simple, this has the drawback, for the delete operation, that two distinct splay operations would be performed.</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \delete_{\splayop}(\emptytup_{\gentree},x) &amp;  &amp; \to\emptytup_{\gentree}\\
 &amp; \delete_{\splayop}(t\equiv\left\langle l,m,r\right\rangle _{\gentree},x) &amp;  &amp; \to\descend(x,t,\left\langle \left[\right],\left[\right]\right\rangle )
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend_{\seqjoin}(t,\emptytup_{\gentree},f)\to\ascend^{\prime}(t,f)\\
 &amp; \descend_{\seqjoin}(\emptytup_{\gentree},t,f)\to\ascend^{\prime}(t,f)\\
 &amp; \descend_{\seqjoin}(\left\langle l_{a},m_{a},r_{a}\right\rangle _{\gentree},\left\langle \emptytup_{\gentree},m_{b},r_{b}\right\rangle _{\gentree},f)\to\\
 &amp; \indent\ascend(m_{b},r_{a},r_{b},\add_{l}(m_{a},l_{a},f))\\
 &amp; \descend_{\seqjoin}(\left\langle l_{a},m_{a},\emptytup_{\gentree}\right\rangle _{\gentree},\left\langle l_{b},m_{b},r_{b}\right\rangle _{\gentree},f)\to\\
 &amp; \indent\ascend(m_{a},l_{a},l_{b},\add_{r}(m_{b},r_{b},f))
\end{aligned}
\\
 &amp; \begin{aligned} &amp; \descend_{\seqjoin}(\left\langle l_{a},m_{a},r_{a}\right\rangle _{\gentree},\left\langle l_{b},m_{b},r_{b}\right\rangle _{\gentree},f)\to\\
 &amp; \indent\descend_{\seqjoin}(r_{a},l_{b},\add_{l}(m_{a},l_{a},\add_{r}(m_{b},r_{b},f)))
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend(x,t\equiv\left\langle l,m,r\right\rangle _{\gentree},f)\to\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent x&lt;m\Rightarrow\descend^{\prime}(x,l,\add_{r}(m,r,f),t,f)\\
 &amp; \indent x&gt;m\Rightarrow\descend^{\prime}(x,r,\add_{l}(m,l,f),t,f)\\
 &amp; \indent x=m\Rightarrow\descend_{\seqjoin}(l,r,t,f)
\end{aligned}
\nonumber \\
\nonumber \\
 &amp; \begin{aligned} &amp; \descend^{\prime}(\_,\emptytup_{\gentree},\_,\left\langle l,m,r\right\rangle _{\gentree},f) &amp;  &amp; \to\ascend(m,l,r,f)\\
 &amp; \descend^{\prime}(x,t,f,\_,\_) &amp;  &amp; \to\descend(x,t,f)
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \ascend^{\prime}(t,\left\langle \left[\right],f\right\rangle ) &amp;  &amp; \to\build(\
ode_{r},t,f)\\
 &amp; \ascend^{\prime}(t,\left\langle f,\left[\right]\right\rangle ) &amp;  &amp; \to\build(\
ode_{l},t,f)
\end{aligned}
\\
 &amp; \begin{aligned} &amp; \ascend^{\prime}(t,\left\langle \left[\left\langle m_{l},l\right\rangle ,f_{l}\ldots\right],f_{r}\right\rangle )\to\ascend(m_{l},l,t,\left\langle f_{l},f_{r}\right\rangle )\end{aligned}
\end{align}
\]
</div>
                        <div class="caption">Implementation of a delete+splay operation</div>
                    </div>
                </p>
                <h2 id="analysis-of-the-splay-operation"><a href="#analysis-of-the-splay-operation">Analysis of the splay operation</a></h2>
                <section>
                    <em class="proofpart">Lemma:</em>
                    <span>The maximum height increase of a tree after a suitably designed splay operation is constant.</span>
                    <p><span class="math">\[
\forall x\in\gentree\colon(\height(\splay(x))-\height(x))\oplus0=O(1)
\]</span></p>
                </section>
                <section>
                    <em class="proofpart">Proof:</em>
                    <span>Splaying the empty tree results in an empty tree, with no height change.</span>
                    <p>For non-empty trees, we analize the behaviour of the previously provided splaying algorithm. In this implementation the splaying operation can be subdivided into a descending phase, and an assembling phase.</p>
                    <p>The descending phase starts with the tree to splay and two lists of trees initially empty, each representing one half of a finger structure. During each step of the descending phase, if the node to bring to the top is not the one being visited, the subtree more distant to the target node is added to the the corresponding list in the finger structure. When the node to bring to the top is visited, a new tree is assembled, by first assembling each of the lists of trees in each side into a tree, and then adding the resulting trees as subtrees of the top node. Therefore, the resulting tree has an height of one plus the maximum height of the subtrees assembled from the lists in the finger structure. Thus proving that the height of the assembled subtree can at most increase by a constant compared to the original tree, is equivalent to proving this lemma.</p>
                    <p>Let <span class="math">\(m\in\mathbb{N}\)</span> be the height of the tree before the splay operation, and <span class="math">\(n\in\mathbb{N}\)</span> the number of descend steps during the splay operation. The maximum possible heights of subtrees added to any of the lists during descend steps can then be described by the sequence <span class="math">\(\left\langle m-1,m-2,\ldots,m-n\right\rangle \)</span>, of which the heights of subtrees added to one of the two lists are a subsequence, with the form <span class="math">\(\left\langle m-n_{1},m-n_{2},\ldots,m-n_{s}\right\rangle \)</span>, where <span class="math">\(n_{x}+1\le n{}_{x+1}\)</span> and <span class="math">\(s\)</span> is the size of the subsequence. It may be noted that <span class="math">\(n_{x}\ge x\)</span></p>
                    <p>During the assembling phase, the subtrees are assembled back in reverse order, starting from the last node, also the one with the minimum of the maximum possible heights of the subtrees.</p>
                    <p>According to the build algorithm defined in (2.21) the maximum height <span class="math">\(\height_{m}\)</span> of a tree assembled from such a subsequence is defined recursively by:</p>
                    <p><span class="math">\[
\begin{eqnarray*}
 &amp;  &amp; \height_{m}(a,b,c,d\ldots)=\height_{m}(a\boxplus(b\boxplus c),d...)\\
 &amp;  &amp; \height_{m}(a,b)=a\boxplus b\\
 &amp;  &amp; \height_{m}(a)=a
 \end{eqnarray*}
\]</span></p>
                    <p>with <span class="math">\(a\boxplus b=(a\oplus b)+1\)</span> and <span class="math">\(a\oplus b=\max(a,b)\)</span>.</p>
                    <p>It is possible to distribute additions of positive values, over the maximum operator:</p>
                    <p><span class="math">\((a\oplus b)+n=(a+n)\oplus(b+n)\)</span> for <span class="math">\(n\in\mathbb{N}\)</span></p>
                    <p>By recursively applying the <span class="math">\(n\in\mathbb{N}\)</span> function and distributing additions, if s is odd, one obtains:</p>
                    <p><span class="math">\[
\height_{m}(x_{s},\ldots,x_{2},x_{1})=(x_{s}+\frac{s-1}{2})\oplus\ldots\oplus(x_{4}+3)\oplus(x_{3}+3)\oplus(x_{2}+2)\oplus(x_{1}+2)
\]</span></p>
                    <p>Substituting <span class="math">\(x_{y}\to m-n_{y}\)</span> <span class="math">\[
\begin{eqnarray*}
\text{} &amp;  &amp; \height_{m}(x_{s},\ldots,x_{2},x_{1})=\\
 &amp;  &amp; =(m-n_{s}+\frac{s-1}{2}\oplus\ldots\oplus(m-n_{4}+3)\oplus(m-n_{3}+3)\oplus(m-n_{2}+2)\oplus(m-n_{1}+2)
\end{eqnarray*}
\]</span></p>
                    <p>Given that <span class="math">\(n_{x}\ge x\)</span>, the maximum possible of these terms is the last one <span class="math">\((m-n_{1}+2)\)</span>. By assuming the minimum value for <span class="math">\(n_{1}\)</span>, one obtains that the maximum possible height of the assembled subtree is <span class="math">\(m+1\)</span>.</p>
                    <p>If s is even: <span class="math">\[
\begin{eqnarray*}
\text{} &amp;  &amp; \height_{m}(x_{s},\ldots,x_{2},x_{1})=(x_{s}+\frac{s}{2})\oplus\ldots\oplus(x_{3}+3)\oplus(x_{2}+3)\oplus(x_{1}+1)
\end{eqnarray*}
\]</span></p>
                    <p>In this case the term with the maximum possible value is <span class="math">\((x_{2}+3)\)</span>. By applying the same steps as above, one similarly obtains that the maximum possible height for the assembled subtree is <span class="math">\(m+1\)</span>.</p>
                    <p>The maximum possible height increase of a tree after the splay operation defined in (2.19) is 2.</p>
                    <p class="proofpart proofend">∎</p>
                </section>
                <section>
                    <em class="proofpart">Lemma:</em>
                    <span>It is possible to design basic operations on splay trees whose maximum height increase is constant. Basic operations on splay trees considered in this lemma are lookup, insert and delete.</span>
                </section>
                <section>
                    <em class="proofpart">Proof:</em>
                    <p>The maximum height increase after a suitably designed splay operation is constant.</p>
                    <p>The height increase after a basic binary tree lookup is zero.</p>
                    <p>The maximum height increase after a basic binary tree insert (2.4) is one, in the case a leaf is added to a node of maximum depth.</p>
                    <p>Thus the maximum height increase after performing a splay operation and a basic binary tree operation, in any order, is constant.</p>
                    <p class="proofpart proofend">∎</p>
                </section>
                <h1 id="massage-operation"><a href="#massage-operation">Incrementally rebalancing a splay tree: the massage operation:</a></h1>
                <p>The <span class="math">\(\massage\)</span> function described here requires that tree nodes are annotated with balance information. When the balancedness of the tree falls below a defined threshold, <span class="math">\(\balancedness_{\massage}\)</span>, the massage function descends the tree along the deepest path and reassembles it to reduces its height by a constant factor. This height reduction is analogous to the <span class="math">\(\splay\)</span> operation and is the main rebalancing operation of massage trees.</p>
                <p>The full massage operation is <span class="math">\(O(\log n)\)</span>, but when <span class="math">\(\balancedness_{\massage}\)</span> is sufficiently small it occurs every <span class="math">\((rk)^{-1}\log n\)</span> operations, where <span class="math">\(n\)</span> is the size of the tree, <span class="math">\(r\)</span> is the height reduction constant and <span class="math">\(k\)</span> is the maximum height increase after each operation. The amortized time complexity of the massage operation is then <span class="math">\(O(rk\log n/\log n)=O(1)\)</span>. </p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
 &amp; \begin{aligned} &amp; \massage(\emptytup_{\baltree})\to\emptytup_{\baltree}\\
 &amp; \massage(t)\to\\
 &amp; \indent\balancedness(t)&lt;\balancedness_{\massage}\Rightarrow\massage_{a}(t)\\
 &amp; \indent\balancedness(t)\ge\balancedness_{\massage}\Rightarrow t
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \massage_{a}(\left\langle l,m,r\right\rangle _{\baltree})\to\end{aligned}
c\\
 &amp; \begin{aligned} &amp; \indent\height(l)&lt;\height(r)\Rightarrow\node(l,m,\massage_{b}(r))\\
 &amp; \indent\height(l)\ge\height(r)\Rightarrow\node(\massage_{b}(l),m,r)
\end{aligned}
\\
\\
 &amp; \begin{aligned} &amp; \massage_{b}(t\equiv\left\langle l,m,r\right\rangle _{\baltree})\to\end{aligned}
\\
 &amp; \begin{aligned} &amp; \indent\height(l)&lt;\height(r)\Rightarrow\massage_{r}(t, &amp; \left\langle l_{l},m_{r},r_{r}\right\rangle _{\baltree} &amp; \mapsto\left\langle \left\langle l,m,l_{r}\right\rangle _{\baltree},m_{r},r_{r}\right\rangle _{\baltree})\\
 &amp; \indent\height(l)\ge\height(r)\Rightarrow\massage_{l}(t, &amp; \left\langle l_{l},m_{l},r_{l}\right\rangle _{\baltree} &amp; \mapsto\left\langle l_{l},m_{l},\left\langle r_{l},m,r\right\rangle _{\baltree}\right\rangle _{\baltree})
\end{aligned}
\\
\nonumber \\
 &amp; \begin{aligned} &amp; \massage_{l}(t\equiv\left\langle \emptytup_{\baltree},m,r\right\rangle _{\baltree},x,f)\to t\\
 &amp; \massage_{l}(\left\langle l,m,r\right\rangle _{\baltree},x,f)\to f(\massage_{a}(l));
\end{aligned}
\\
\\
 &amp; \begin{aligned} &amp; \massage_{r}(t\equiv\left\langle l,m,\emptytup_{\baltree}\right\rangle _{\baltree},x,f)\to t\\
 &amp; \massage_{r}(\left\langle l,m,r\right\rangle _{\baltree},x,f)\to f(\massage_{a}(r));
\end{aligned}
\end{align}
\]</div>
                        <div class="caption">Implementation of an incremental rebalancing operation for splay trees</div>
                    </div>
                </p>
                <h2 id="operations-on-massage-trees"><a href="#operations-on-massage-trees">Operations on massage trees</a></h2>
                <p>As with <span class="math">\(\splay\)</span>, <span class="math">\(\massage\)</span> is combined with each of the defined operations on splay trees: </p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{equation}
\begin{aligned} &amp; \member_{\massageop}(t,x)\to\\
 &amp; \indent\left\langle t,r\right\rangle \leftarrowtail\member_{\splayop}(t,x)\\
 &amp; \indent\left\langle \massage(t),r\right\rangle \\
\\
 &amp; \insert_{\massageop}(t,x)\to\massage(\insert_{\splayop}(t,x))\\
 &amp; \delete_{\massageop}(t,x)\to\massage(\delete_{\splayop}(t,x))
\end{aligned}
\end{equation}
\]</div>
                    </div>
                </p>
                <p>The massage operation may equivalently be performed  or  the corresponding function for splay trees: <span class="math">\[
\begin{equation}
\begin{cases}
 &amp; f_{1}(t,x)=\massage(f_{\splayop}(t,x))\\
 &amp; f_{2}(t,x)=f_{\splayop}(\massage(t),x)
\end{cases}
\end{equation}
\]</span></p>
                <p>The freedom in the order execution of the splay and massage operations, allows embedding the rebalancing operation into the splay operation.</p>
                <h1 id="experimental-results"><a href="#experimental-results">Experimental results</a></h1>
                <p>
                    <em>Section to be expanded...</em>
                </p>
                <h1 id="applications"><a href="#applications">Applications</a></h1>
                <h2 id="queues"><a href="#queues">Queues</a></h2>
                <p>Queue operations can be defined efficiently on massage trees: </p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
\begin{aligned} &amp; f\in\left\{ \queuepush,\queuepop\right\} \\
 &amp; \splay_{\seqfirst}(t)=\splay(t,\seqfirst(t))\\
 &amp; f_{s}(t,x)=\massage(f_{s,\genop}(\splay_{\seqfirst}(t),x))
\end{aligned}
\end{align}
\]</div>
                    </div>
                </p>
                <h2 id="deques"><a href="#deques">Deques</a></h2>
                <p>Similarly, deque operations can be defined on massage trees:</p>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\[
\begin{align}
\begin{aligned} &amp; f\in\left\{ \queuepush,\queuepop\right\} \\
 &amp; s\in\left\{ \seqlast,\seqfirst\right\} \\
 &amp; \splay_{s}=(t)\mapsto\splay(t,s(t))\\
 &amp; \splay_{\seqfirst,\seqlast}=\splay_{\seqfirst}\cdot\splay_{\seqlast}\\
 &amp; f_{s}(t,x)\to\massage(f_{s,\genop}(\splay_{\seqfirst,\seqlast}(t),x))
\end{aligned}
\end{align}
\]</div>
                    </div>
                </p>
                <p>The <span class="math">\(\splay_{\seqfirst,\seqlast}\)</span> operation splays both the first and the last node of the tree. This is necessary to make subsequent accesses to any of the ends of the deque constant-time.</p>
                <h2 id="dynamic-arrays"><a href="#dynamic-arrays">Dynamic arrays</a></h2>
                <p>
                    <div class="le-code-cont">
                        <div class="leCode math">\begin{align*}
 & \begin{aligned} & \seqjoin_{\genop}(\emptytup_{\baltree},x)\to x\\
 & \seqjoin_{\genop}(x,\emptytup_{\baltree})\to x\\
 & \seqjoin_{\genop}(\left\langle \_,l_{a},m_{a},r_{a}\right\rangle _{\baltree}\equiv a,b\equiv\left\langle \_,l_{b},m_{b},r_{b}\right\rangle _{\baltree})\to\\
 & \indent\size(a)<\size(b)\Rightarrow\node(\seqjoin_{\genop}(a,l_{b}),m_{b},r_{b})\\
 & \indent\size(a)\ge\size(b)\Rightarrow\node(l_{a,}m_{a},\seqjoin_{\genop}(r_{a},b))\\
\\
\end{aligned}
\\
 & \begin{aligned} & \seqjoin(\emptytup_{\baltree},x)\to x\\
 & \seqjoin(x,\emptytup_{\baltree})\to x\\
 & \seqjoin(a,b)\to\\
 & \indent\massage(\seqjoin_{\genop}(\splay_{\seqlast}(a),\splay_{\seqfirst}(b)))
\end{aligned}
\\
\\
 & \begin{aligned} & \seqsplit(t,n)\to\begin{split}\end{split}
\\
 & \indent\left\langle a,b\right\rangle \leftarrowtail\seqsplit_{\genop}(t,n)\\
 & \indent\left\langle \massage(a),\massage(b)\right\rangle 
\end{aligned}
\\
\\
 & \begin{aligned} & \seqsplit_{\genop}(\emptytup_{\baltree},n)\to\left\langle \emptytup_{\baltree},\emptytup_{\baltree}\right\rangle \\
 & \seqsplit_{\genop}(t\equiv\left\langle l,m,r\right\rangle _{\baltree},n)\to
\end{aligned}
\\
 & \begin{aligned} & \indent n<\size(l) &  & \Rightarrow\seqsplit_{l}(l,m,r,n)\\
 & \indent n>\size(l)+1 &  & \Rightarrow\seqsplit_{r}(l,m,r,n-(\size(l)+1)\\
 & \indent n=\size(l) &  & \Rightarrow\left\langle l,\left\langle \emptytup_{\baltree},m,r\right\rangle _{\baltree}\right\rangle \\
 & \indent n=\size(l)+1 &  & \Rightarrow\left\langle \left\langle l,m,\emptytup_{\baltree}\right\rangle _{\baltree},r\right\rangle 
\end{aligned}
\\
\\
 & \begin{aligned} & \seqsplit_{l}(l,m,r,n)\to\\
 & \indent\left\langle a,b\right\rangle \leftarrowtail\seqsplit_{\genop}(l,n)\\
 & \indent\left\langle a,\left\langle b,m,r\right\rangle _{\baltree}\right\rangle 
\end{aligned}
\\
\\
 & \begin{aligned} & \seqsplit_{r}(l,m,r,n)\to\\
 & \indent\left\langle a,b\right\rangle \leftarrowtail\seqsplit_{\genop}(r,n)\\
 & \indent\left\langle \left\langle l,m,a\right\rangle _{\baltree},b\right\rangle 
\end{aligned}
\end{align*}</div>
                        <div class="caption">Implementation of split and join operations for binary trees representing arrays</div>
                    </div>
                </p>
                <p>Massage trees can be used to implement dynamic arrays efficently.</p>
                <p>The split operation is implemented as a variant of the splay operation.</p>
                <h2 id="linked-lists"><a href="#linked-lists">Linked-lists</a></h2>
                <p>Massage trees support linked-list operations.</p>
                <h2 id="ropes"><a href="#ropes">Ropes</a></h2>
                <p>Massage trees make it possible to implement a functional alternative to gap buffers; with additional advantages:</p>
                <ul>
                    <li>performance never degrades to linear for any operations or worst cases</li>
                    <li>straightforward support of versioning and undo</li>
                </ul>
                <h1 id="conclusions"><a href="#conclusions">Conclusions</a></h1>
                <p>Massage Trees:<ul>
                        <li>extend the applications of self-adjusting trees to areas initially covered only by balanced trees.</li>
                        <li>extend the applications of balanced trees to areas so far only covered by ad-hoc structures, like queues, lists or stacks.</li>
                    </ul>
                </p>
                <p>Data-structures implemented by massage trees adapt interactively to different usage patterns, reducing or eliminating the need to transform the data into specialized structures for efficient processing:<ul>
                        <li>logarithmic worst-case time bounds for all operations</li>
                        <li>amortized constant times for focal operations</li>
                    </ul>
                </p>
                <h1 id="literature-cited">Literature Cited</h1>
                <p>Daniel Dominic Sleator and Robert Endre Tarjan, 1985. Self-Adjusting Binary Search Trees.
AT&T Bell Laboratories, Murray Hill, NJ; Journal of the Association for Computing Machinery. Vol. 32, No. 3, July 1985, pp. 652-686.
</p>
            </div>
        </div>
    </body>
</html>